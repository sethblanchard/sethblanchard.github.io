'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = _interopDefault(require('path'));
var fs = _interopDefault(require('fs'));
var glob = _interopDefault(require('glob'));
var babel = _interopDefault(require('babel-core'));

// internal tooling
// access file
var access = (function (pathname) {
	return new Promise(function (resolve, reject) {
		return fs.access(pathname, function (error) {
			return error ? reject(error) : resolve([pathname]);
		});
	});
});

// internal tooling
// external tooling
// glob
var glob$1 = (function (id, cwd, opts) {
	return new Promise(function (resolve, reject) {
		return glob(id, Object.assign({
			cwd: cwd,
			nodir: true
		}, opts), function (error, files) {
			return error ? reject(error) : files.length ? resolve(files.map(function (file) {
				return path.join(cwd, file);
			})) : reject(files);
		});
	});
});

var babelHelpers = {};
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();



































var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

babelHelpers;

// internal tooling
// read json from pathname
var json = (function (_ref) {
	var _ref2 = slicedToArray(_ref, 1),
	    pathname = _ref2[0];

	return new Promise(function (resolve, reject) {
		return fs.readFile(pathname, 'utf8', function (error, result) {
			return error ? reject(error) : resolve(JSON.parse(result));
		});
	});
});

// #ESLit.resolve (promise resolved literals)
var resolve = (function (members) {
	for (var _len = arguments.length, literals = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		literals[_key - 1] = arguments[_key];
	}

	return Promise.all(getResolvedPromises(literals)).then(function () {
		return members.reduce(function (previousValue, currentValue, currentIndex) {
			var currentLiteral = literals[currentIndex - 1];

			var resolvedLiteral = Array.isArray(currentLiteral) ? currentLiteral.join('') : String(currentLiteral);

			return '' + previousValue + resolvedLiteral + currentValue;
		});
	});
});

var getResolvedPromises = function getResolvedPromises(object) {
	var promises = [];

	if (object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object') {
		var _loop = function _loop(key) {
			var element = object[key];

			if (element instanceof Promise) {
				promises.push(element.then(function (result) {
					object[key] = result;
				}));
			}

			promises.push.apply(promises, getResolvedPromises(element));
		};

		for (var key in object) {
			_loop(key);
		}
	}

	return promises;
};

// external tooling
// transform(string)
var transform = (function (string) {
	return babel.transform('(function () {\n  "use strict";\n  return`' + string + '`;\n})();', {
		plugins: [function () {
			return {
				visitor: {
					TemplateLiteral: function TemplateLiteral(tPath) {
						// whether the Template Literal is tagged
						var isTaggedTemplateExpression = tPath.parentPath.isTaggedTemplateExpression();

						if (!isTaggedTemplateExpression) {
							// tag the Template Literal
							tPath.replaceWith(babel.types.taggedTemplateExpression(babel.types.identifier('include.resolve'), tPath.node));
						}
					}
				}
			};
		}]
	}).code.slice(14, -5);
});

// local tooling
// parse (parse content using data)
function parse() {
	var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

	var _Function$prototype$b;

	var rawdata = arguments[1];
	var rawopts = arguments[2];

	// assigned data
	var data = Object.assign({}, rawdata);

	// keys from data
	var keys = Object.keys(data);

	// args from data
	var args = keys.map(function (key) {
		return data[key];
	});

	var eslitRequire = function eslitRequire(newsrc, newdata, newopts) {
		return include$1(newsrc, Object.assign({}, rawdata, newdata), Object.assign({}, rawopts, newopts));
	};

	eslitRequire.parse = function (newstring, newdata, newopts) {
		return parse(newstring, Object.assign({}, rawdata, newdata), Object.assign({}, rawopts, newopts));
	};

	eslitRequire.resolve = resolve;

	// function constructor bound to keys
	var ESLitFunction = (_Function$prototype$b = Function.prototype.bind).call.apply(_Function$prototype$b, [Function, null, 'include'].concat(toConsumableArray(keys)));

	// new ESLit Function returning resolving template literals
	var newESLitFunction = new ESLitFunction(transform(string));

	// executed function returning resolving template literals
	var promise = newESLitFunction.apply(undefined, [eslitRequire].concat(toConsumableArray(args)));

	return promise;
}

// internal tooling
// readFile, then-ified
var read = (function (file) {
	return new Promise(function (resolve, reject) {
		return fs.readFile(file, 'utf8', function (error, content) {
			return error ? reject(error) : resolve(content);
		});
	});
});

// internal tooling
// local tooling
// return array of closest path(s)
var include$1 = (function (rawsrc, rawdata, rawopts) {
	var _Object = Object(rawopts),
	    _Object$cwd = _Object.cwd,
	    cwd = _Object$cwd === undefined ? process.cwd() : _Object$cwd,
	    _Object$prefixes = _Object.prefixes,
	    prefixes = _Object$prefixes === undefined ? ['_'] : _Object$prefixes,
	    _Object$extensions = _Object.extensions,
	    extensions = _Object$extensions === undefined ? ['.html', '.jsx'] : _Object$extensions,
	    _Object$globopts = _Object.globopts,
	    globopts = _Object$globopts === undefined ? {} : _Object$globopts;

	var src = path.relative(cwd, path.isAbsolute(String(rawsrc)) ? rawsrc : path.join(cwd, String(rawsrc)));
	var srcs = src.split(path.sep);
	var cwds = cwd.split(path.sep);

	var hasPaths = srcs.length > 1;

	return [].concat(
	// assemble extension combinations
	Array.isArray(extensions) ? extensions.map(function (extension) {
		return ['', extension];
	}) : []).concat(
	// assemble prefix combinations
	Array.isArray(prefixes) ? prefixes.map(function (prefix) {
		return [prefix, ''];
	}) : []).concat(
	// assemble prefix + extension combinations
	Array.isArray(prefixes) ? prefixes.map(function (prefix) {
		return Array.isArray(extensions) ? extensions.map(function (extension) {
			return [prefix, extension];
		}) : [];
	}) : []).reduce(
	// return accessible src, src+extension, prefix+src, or prefix+src+extension
	function (promise, _ref) {
		var _ref2 = slicedToArray(_ref, 2),
		    prefix = _ref2[0],
		    extension = _ref2[1];

		return promise.catch(function () {
			return access(path.join.apply(path, [cwd].concat(toConsumableArray( // eslint-disable-line no-extra-parens
			hasPaths ? srcs.slice(0, -1).concat(prefix + srcs.slice(-1)[0] + extension) : [prefix + src + extension]))));
		});
	}, access(path.join(cwd, src))).catch(
	// return accessible glob src
	function () {
		return glob$1(src, cwd, globopts);
	}).catch(function () {
		return cwds.map(
		// assemble module combinations
		function (eachcwd, index) {
			return path.join.apply(path, [cwds.slice(0, index + 1).join(path.sep), 'node_modules', srcs[0]].concat(toConsumableArray( // eslint-disable-line no-extra-parens
			hasPaths ? srcs.slice(1) : ['package.json'])));
		}).reverse().reduce(
		// return accessible module src, or module src+package.json file
		function (promise, pathname) {
			return promise.catch(function () {
				return hasPaths ? access(pathname) : access(pathname).then(json).then(function (pkg) {
					return getPackageFile(path.dirname(pathname), pkg);
				});
			});
		}, Promise.reject());
	}).catch(function () {
		return [];
	}).then(function (allsrcs) {
		return Promise.all(allsrcs.map(function (eachsrc) {
			return read(eachsrc).catch(function (error) {
				return error.code === 'EISDIR' ? json([path.join(eachsrc, 'package.json')]).then(function (pkg) {
					return getPackageFile(eachsrc, pkg).then(function (_ref3) {
						var _ref4 = slicedToArray(_ref3, 1),
						    innersrc = _ref4[0];

						return read(innersrc);
					});
				}) : Promise.reject(error);
			});
		})).then(function (strings) {
			return parse(strings.join(''), rawdata, Object.assign({}, rawopts, {
				cwd: path.dirname(allsrcs[0])
			}));
		});
	});
});

var getPackageFile = function getPackageFile(dirname, pkg) {
	return access(path.join(dirname, pkg.template || pkg.main || 'index.html'));
};

// local tooling
include$1.parse = parse;
include$1.resolve = resolve;

module.exports = include$1;
//# sourceMappingURL=index.dist.js.map
